1)Стек
2)Очередь
3)ДЭК

Очередь не сильно отличается от стека - с одной стороны добавляем с другой забираем

list()
{
x = []
x.append()
y = x.pop()
}
 Лист нужно использовать если нам нужен просто стек


Для использования очереди нужно использовать

from queue import Queue
q = Queue() - создем очередь
q.put(el) - чтобы добавить
y = q.get() - чтобы достать

кроме очереди здесь есть стек и куча, но это сами или попозже

from collections dequeue
q = dequ(el)
q.append(el) - добавляет в конец справа
чтобы забрать слева
y = q.popleft()

есть разница между Queue и dequeu

все что находить в 1) они предназначены для нитевых программ
мы можем это штуку использовать сразу в нескольких нитях
из одной забрать в другую добавить

если из пустой очереи что-то забрать, то программа навечно зависнет, так как будет вечно ждать что в неё кто-то что-то положит
правильнее будет использовать deque потому что если будем забирать из пустой очереди то она выдаст ошибку

всё что находиться в библиотеке queue рассчитано на работу с несколькими нитями

что такое дерево?
Дерево - это когда у нас есть какой-то корень и у него есть несколько веточек у них тоже есть несколько веточек
и так далее

       0
   0   0   0
 0  0     0 0
0  0 0
сегодня будем рассматривать бинарные деревья
т.е. у каждого узла ест ровно два потомка
     0
  0     0
 0 0   0 0

куча - двоичное дерево которое
1)заполняется слева направо (heap)
2)элемент которые находится в узле должен быть меньше либо больше( в зависимости от того какую кучу мы делаем - максимальную или минимальную
элементов которые от него отходят

     4
  6     10
7 12   11 20


Построим кучу
 8 7 11 2 0 25

 8
7

не выполняется правило что элемент сверху меньше чем элемент снизу
значит меняем местами

 7
8

дальше куда добавляем 11?
рядом с 8
  7
 8 11

 добавляем 3 и меняем местами

  3
 7  11
8

Добавляем 0 и меняем местами

    0
 3     11
8 7   25

можем забрать 0, т.к. точно знаем что он минимальный
на его место ставим 25

но тогда дерево нужно персобрать

   25
 3   11
8 7

    3
 25   11
8  7

   3
 7   11
8 25

получили снова кучу.
можем снова забрать минимальный элемент и перестроить
и так по кругу

получим в конце

0 3 7 8 11 25

получили отсортированный список по возрастанию

оценим сколько операций нам надо было сделать
нужно сделать log(2) N операций чтобы понять куда поместить
когда помещаем элемент, то O(n log n)
когда забираем, то O(n log n)

Получаем что кучу можно использовать для сортировки
Плохо что сортировка всегда работает за O(n log n)
плюс мы не можем распараллелить эту сортировку как например в сортировке слиянием
а за счет этого можно получить больший прирост

когда нужна эта структура?

Она хорошо, что мы всегда достаточно быстро можем забарть минимальный или максимальный элемент

Если сравнивать кучу со списком, то в списке элемент можно просто положить в конец, но чтобы найти минимальный нужно пробежать
весь список, то есть добавлем быстрее, но забираем дольше

можно сказать что можно добавить, отсортировать и потом забрать

но что если в момент прохода нам нужно добавить элемент?

если у нас задача в рамках которой нам постоянно нужно в список что-то складывать и забирать мин(макс)

В основном это задачи с приоритетом
имеется список приоритетов
сделали самое приоритетное, потом вспомнили что нужно еще что-то сделать и добавили в список


куча всегда заполняется сверху вниз и слева направо
то можно сказать что эта куча взаимно отображается на список

    0
 3     11     --->  [0,3,11,8,7,25]
8 7  25

Если есть узел, то какие номера будут у его потомков?
узел - i
потомки - 2i+1 и 2i+2
     i
2i+1  2i+2

если наоборот то
предок i - (i-1)//2
попробуем реализовать в коде

Генерить ошибки полезно чтобы другой программист если что понял что ему хочет сказать питон

реализовали код
Как сделать из случайног списка кучу?
10 3 7 5 11 1 2

предпололжим что это уже типо куча

    10
  3     7
5 11   1 2

смотрим подкучу

 3
5 11

переходим к другой

 7
1 2

меняем местами
получаем
 1
7 2

возвращаемся к куче

получаем

    1
 3      2
5 11   7 10

(len(h) - 1)//2 может быть и минус 2 Герцев не уверен

сколько нужно сделать операций
Суммируем от 0 до H по уровням, где
h = 0 - самая нижняя часть дерева
h*[n/2**(h+1)]

дальше - см.фото

получаем О(4n)
то есть O(n)


пирамидаидальная сортировка

Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности.
Для восстановления этого свойства служит процедура Heapify.
Она восстанавливает свойство кучи в дереве, у которого левое и правое поддеревья удовлетворяют ему.
Эта процедура принимает на вход массив элементов A и индекс i.
Она восстанавливает свойство упорядоченности во всём поддереве, корнем которого является элемент A[i].

